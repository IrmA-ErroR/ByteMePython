import sys

def balloon_show(N, matrix):
    '''Художник N создал перформанс управляемых миниатюрных воздушных шаров. Они парят в ночном небе в виде квадрата N×N и светятся. С помощью нейросети художник сгенерировал палитру из N^2 цветов в формате OKLCH и присвоил каждому цвету порядковый номер. Полученная палитра обладает следующим свойством: пара цветов с порядковыми номерами i, j считается красивой, если i<j. Путь из шаров в квадрате считается красивым, если цвета всех соседних пар шаров красивы, а последний шар находится на краю квадрата. В качестве соседей шара учитываются только вертикальные и горизонтальные шары, но не диагональные.

    Определить количество воздушных шаров в самом длинном красивом пути, а также количество таких путей в случайно заданной расстановке.'''

    # Инициализация: для каждой клетки длина 1 и количество путей 1
    dp_length = [[1 for _ in range(N)] for _ in range(N)]
    dp_count = [[1 for _ in range(N)] for _ in range(N)]

    # Список всех клеток, отсортированный по возрастанию значения
    cells = []
    for i in range(N):
        for j in range(N):
            cells.append((matrix[i][j], i, j))
    cells.sort()

    # Обходим клетки в порядке возрастания значений
    for val, i, j in cells:
        # Проверяем всех 4 соседей
        for di, dj in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
            ni, nj = i + di, j + dj
            if 0 <= ni < N and 0 <= nj < N:
                if matrix[ni][nj] < val:
                    if dp_length[ni][nj] + 1 > dp_length[i][j]:
                        dp_length[i][j] = dp_length[ni][nj] + 1
                        dp_count[i][j] = dp_count[ni][nj]
                    elif dp_length[ni][nj] + 1 == dp_length[i][j]:
                        dp_count[i][j] += dp_count[ni][nj]

    # Находим максимальную длину и количество путей среди клеток на краю
    max_len = 0
    total_count = 0

    for i in range(N):
        for j in range(N):
            if i == 0 or i == N-1 or j == 0 or j == N-1:  # Клетка на краю
                if dp_length[i][j] > max_len:
                    max_len = dp_length[i][j]
                    total_count = dp_count[i][j]
                elif dp_length[i][j] == max_len:
                    total_count += dp_count[i][j]

    return max_len, total_count

def main():
    """
    Для чтения входных данных необходимо получить их
    из стандартного потока ввода (sys.stdin).
    Данные во входном потоке соответствуют описанному
    в условии формату. Обычно входные данные состоят
    из нескольких строк.
    Можно использовать несколько методов:
    * input() -- читает одну строку из потока без символа
    перевода строки;
    * sys.stdin.readline() -- читает одну строку из потока,
    сохраняя символ перевода строки в конце;
    * sys.stdin.readlines() -- вернет список (list) строк,
    сохраняя символ перевода строки в конце каждой из них.
    Чтобы прочитать из строки стандартного потока:
    * число -- int(input()) # в строке должно быть одно число
    * строку -- input()
    * массив чисел -- map(int, input().split())
    * последовательность слов -- input().split()
    Чтобы вывести результат в стандартный поток вывода (sys.stdout),
    можно использовать функцию print() или sys.stdout.write().
    Возможное решение задачи "Вычислите сумму чисел в строке":
    print(sum(map(int, input().split())))
    """
    # Чтение входных данных
    n = int(input())
    matrix = [list(map(int, input().split())) for _ in range(n)]

    # Получение результата
    result = balloon_show(n, matrix)
    print(result[0], result[1])
    return 0



if __name__ == '__main__':
    main()
